<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[SonarQube 代码质量管理平台的搭建]]></title>
      <url>%2F2017%2F06%2F15%2FSonarQube%2F</url>
      <content type="text"><![CDATA[背景： 由于公司项目用的是自己的内部框架，没有引入spring，例如获取数据库的session等操作，都是需要手动操作的，操作多了难免会造成session的未关闭等问题。上周就是因为session的为关闭导致应用运行一段时间后，莫名的不再接受任何请求和处理，也没有任何的异常信息，就像卡住一样。因此排查问题浪费了很多时间，最后检查代码才发现有一处因为数据库的session未关闭的原因造成的。其实如果用到了代码检查工具，这些细节问题是完全可以避免的。 这里推荐使用开源的SonarQube质量管理平台工具 下面是搭建步骤：1、准备环境 jdk1.8 mysql5.6+ 2、 安装mysql并创建数据库sonar1234567891011# mysql -u root -p# mysql&gt; CREATE DATABASE sonar CHARACTER SET utf8 COLLATE utf8_general_ci;# mysql&gt; CREATE USER &apos;sonar&apos; IDENTIFIED BY &apos;sonar&apos;;# mysql&gt; GRANT ALL ON sonar.* TO &apos;sonar&apos;@&apos;%&apos; IDENTIFIED BY &apos;sonar&apos;;# mysql&gt; GRANT ALL ON sonar.* TO &apos;sonar&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;sonar&apos;;# mysql&gt; FLUSH PRIVILEGES; 3、 下载安装包服务端工具：sonarqube:http://www.sonarqube.org/downloads/ 客户端工具sonar-runner:http://repo1.maven.org/maven2/org/codehaus/sonar/runner/sonar-runner-dist/2.3/sonar-runner-dist-2.4.zip 4、 安装SonarQube 第一步： 将下载的SonarQube解压安装到/usr/local 目录下。具体步骤如下： 12345# wget -c http://downloads.sonarsource.com/sonarqube/sonarqube-5.1.1.zip# unzip sonarqube-5.1.1.zip# mv sonarqube-5.1.1 /usr/local/ 第二步： 配置环境变量 123456789vim + /etc/profile`添加SONAR_HOME=/usr/local/sonarqube-5.1.1 export SONAR_HOME保存退出并使配置生效source /etc/profile 第三步： 修改配置文件sonar.properties 123456789# vim /usr/local/sonarqube-5.1.1/conf/sonar.properties打开后，找到sonar.host.url=http://192.168.1.168:9000sonar.jdbc.username=rootsonar.jdbc.password=123456sonar.jdbc.url=jdbc:mysql://localhost:3306/sonar?useUnicode=true&amp;characterEncoding=utf8&amp;rewriteBatchedStatements=true&amp;useConfigs=maxPerformancesonar.web.host=0.0.0.0sonar.web.context=/sonar.web.port=9000 第四步： 修改配置文件wrapper.conf wrapper.java.command=/usr/local/sonar/jdk/bin/java 注意：把wrapper.conf中的wrapper.java.command修改成jdk1.8路径否则会找系统自带jdk版本的命令执行，启动的时候可能报错 , bin后面还需要加上/java 第五步： 启动服务 # /usr/local/sonarqube-5.1.1/bin/linux-x86-64/sonar.sh start &nbsp;&nbsp;另外，启动/停止/重启命令如下： 12345678910111213# ./sonar.sh start 启动服务 # ./sonar.sh stop 停止服务 # ./sonar.sh restart 重启服务查看启动日志:# tail -f /usr/local/sonarqube-5.6.6/logs/sonar.log关闭命令:# ./sonar.sh stop登录：http://localhost:9000默认密码:admin/admin 第六步： 访问SonarQube Web管理界面。如果能够看到这个界面证明SonarQube安装成功啦。 注：我这里访问的地址是：http://192.168.1.168:9000 5、 安装SonarQube Runner 第一步：将下载的http://repo1.maven.org/maven2/org/codehaus/sonar/runner/sonar-runner-dist/2.4/sonar-runner-dist-2.4.zip解压后放到/usr/local目录下。具体步骤如下： 123# wget -c http://repo1.maven.org/maven2/org/codehaus/sonar/runner/#sonar-runner-dist/2.4/sonar-runner-dist-2.4.zip# unzip sonar-runner-dist-2.4.zip# mv sonar-runner-2.4/ /usr/local/ 第二步：配置环境变量 123456789# vim + /etc/profile添加SONAR_RUNNER_HOME=/usr/local/sonar-runner-2.4/PATH=.:$SONAR_RUNNER_HOME/bin export SONAR_RUNNER_HOME保存并退出 # source /etc/profile 第三步：配置sonar-runner.properties 12345678910# vim /usr/local/sonar-runner-2.4/conf/sonar-runner.properties找到sonar.host.url=http://192.168.1.168sonar.jdbc.url=jdbc:mysql://localhost:3306/sonar?useUnicode=true&amp;amp;characterEncoding=utf8sonar.jdbc.username=sonarsonar.jdbc.password=sonarsonar.login=adminsonar.password=admin将前面的#去掉 第四步：运行sonar-runner分析源代码 Sonar官方已经提供了非常全的代码样例便于新手入门用。 下载地址：https://github.com/SonarSource/sonar-examples/archive/master.zip 下载后使用unzip解压。进入java执行sonar-runner命令即可。操作命令如下： 1234# wget -c https://github.com/SonarSource/sonar-examples/archive/master.zip# unzip master.zip# cd sonar-examples-master/projects/languages/java/maven/# sonar-runner 如果能够看到下面的输出信息，证明你的SonarQube Runner安装并配置正确啦。 123456INFO: ------------------------------------------------------------------------INFO: EXECUTION SUCCESSINFO: ------------------------------------------------------------------------Total time: 2:59.167sFinal Memory: 17M/204MINFO: ------------------------------------------------------------------------ 第五步：看看SonarQube的Web界面，是否已经可以看到分析的结果啦。 6、扫描项目 (1) maven环境 (推荐方式，比较方便，扫描完了自动上传结果至sonar服务器中) Maven仓库中就有SonarQube Scanner工具的插件，只要在$M2_HOME/conf/setting.xml文件中添加如下配置 1234567891011121314151617181920212223&lt;pluginGroups&gt; &lt;pluginGroup&gt;org.sonarsource.scanner.maven&lt;/pluginGroup&gt;&lt;/pluginGroups&gt;&lt;profile&gt; &lt;id&gt;sonar&lt;/id&gt;&lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;&lt;/activation&gt;&lt;properties&gt; &lt;sonar.host.url&gt;http://192.168.1.168:9000/sonarqube&lt;/sonar.host.url&gt;&lt;/properties&gt;&lt;/profile&gt; 配置完成后，在项目中，执行mvn sonar:sonar，SonarQube Scanner会自动扫描，根据pom.xml文件得出项目相关信息，不需要自定义sonar-project.properties。扫描完成后就会上传只Sonarqube服务器中。稍后，登陆服务器中就可以看到分析结果了。 (2) 手动扫描 1234567891011121314151617181920212223242526272829303132333435打开要进行代码分析的项目根目录，新建sonar-project.properties文件sonar.projectKey=my:task# this is the name displayed in the SonarQube UIsonar.projectName=My tasksonar.projectVersion=1.0sonar.projectDescription= task 定时任务调度# Path is relative to the sonar-project.properties file. Replace &quot;\&quot; by &quot;/&quot; on Windows.# Since SonarQube 4.2, this property is optional if sonar.modules is set.# If not set, SonarQube starts looking for source code from the directory containing# the sonar-project.properties file.#sources是源文件所在的目录sonar.sources=master/src,slave/srcsonar.binaries=WebRoot/WEB-INF/classes# Encoding of the source code. Default is default system encodingsonar.language=javasonar.my.property=valuesonar.sourceEncoding=UTF-8在项目跟目录执行 输入命令：sonar-runner 7、SonarQube默认是没有安装中文语言包的。如何安装语言包呢？进入SonarQube插件目录，下载语言包即可。步骤如下12# cd /usr/local/sonarqube-5.1.1/extensions/plugins# wget -c http://repo1.maven.org/maven2/org/codehaus/sonar-plugins/l10n/sonar-l10n-zh-plugin/1.8/sonar-l10n-zh-plugin-1.8.jar 这是中文语言包的源码地址：https://github.com/SonarCommunity/sonar-l10n-zh]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[springboot-storm-integration]]></title>
      <url>%2F2017%2F06%2F01%2Fspring-storm-integration%2F</url>
      <content type="text"><![CDATA[最近在搭建storm与springboot框架的集成，由于本身对storm分布式框架的不熟悉，加上网上能搜到的spring与storm集成的案例也比较少，这一路走来真的是各种坎坷啊，所以也在此总结一下遇到的一些问题，同时也希望能帮到有需要的朋友。 在搭建框架之前，有必要先熟悉一下storm的topology在提交过程中，初始化了什么，实例化了哪些类？ (1) 首先简单说一下，提交topology的流程： 1、首先定义好topology的Config，实例化DrpcSpout、以及Bolt之间的拓扑结构 2、提交Topology之前确认storm的各种服务都启动了，包括zk、nimbus、supervisor、logviewer、ui 3、提交Topology实例给nimbus，这时候调用TopologyBuilder实例的createTopology()方法，以获取定义的Topology实例。在运行createTopology()方法的过程中，会去调用Spout和Bolt实例上的declareOutputFields()方法和getComponentConfiguration()方法，declareOutputFields()方法配置Spout和Bolt实例的输出，getComponentConfiguration()方法输出特定于Spout和Bolt实例的配置参数值对。Storm会将以上过程中得到的实例，输出配置和配置参数值对等数据序列化，然后传递给Nimbus。 4、Worker Node上运行的thread，从nimbus上复制序列化后得到的字节码文件，从中反序列化得到Spout和Bolt实例，实例的输出配置和实例的配置参数值对等数据，在thread中Spout和Bolt实例的declareOutputFields()和getComponentConfiguration()不会再运行。 4、在thread中，反序列化得到一个Bolt实例后，它会先运行Bolt实例的prepare()方法，在这个方法调用中，需要传入一个OutputCollector实例，后面使用该OutputCollector实例输出Tuple 5、接下来在该thread中按照配置数量建立task集合，然后在每个task中就会循环调用thread所持有Bolt实例的execute()方法 6、在关闭一个thread时，thread所持有的Bolt实例会调用cleanup()方法 （2）storm与springboot的集成 1、定义springboot的主入口，也就是Application的启动类 123456@Configuration@EnableAutoConfiguration@ComponentScan(basePackages=&quot;com.demo&quot;)public class Main extends ApplicationObjectSupport &#123;&#125; 2、由于storm的每个bolt都相当于独立的应用，正好每个bolt提供了一个prepare方法，这个prepare方法是在topology提交的时候调用的，这个时候可以把加载spring的过程，放在此处，从而也保证了每个bolt都能获取到Spring的ApplicationContext，有了ApplicationContext，后面的一切都好说了，springboot的任何功能的可以正常使用。废话不说直接贴代码： 123456public void prepare(Map stormConf, TopologyContext context) &#123; super.prepare(stormConf, context); logger.info(&quot;Main start...&quot;); new SpringApplicationBuilder(Main.class).web(false).run(new String[]&#123;&#125;); logger.info(&quot;Main end...&quot;);&#125; 3、获取ApplicationContext前，还需要实现ApplicationContextAware接口，注意一定要加上@Component，spring才会去加载当前类 1234567891011121314151617181920212223242526272829303132@Componentpublic class BeanUtils implements ApplicationContextAware&#123; private static ApplicationContext applicationContext = null; @Override public void setApplicationContext(ApplicationContext arg0) throws BeansException &#123; if (BeanUtils.applicationContext == null) &#123; BeanUtils.applicationContext = arg0; &#125; &#125; // 获取applicationContext public static ApplicationContext getApplicationContext() &#123; return applicationContext; &#125; // 通过name获取 Bean. public static Object getBean(String name) &#123; return getApplicationContext().getBean(name); &#125; // 通过class获取Bean. public static &lt;T&gt; T getBean(Class&lt;T&gt; clazz) &#123; return getApplicationContext().getBean(clazz); &#125; // 通过name,以及Clazz返回指定的Bean public static &lt;T&gt; T getBean(String name, Class&lt;T&gt; clazz) &#123; return getApplicationContext().getBean(name, clazz); &#125;&#125; 4、通过ApplicationContext获取Service实现类,注意Service一定要加上@Service(name=”demoService”)，不加别名的话，会获取不到，你可以试一下。(DemoService) applicationContext.getBean(&quot;demoService&quot;); 到此简单的整合就完成了，重点是每个bolt都需要独立的ApplicationContext，才能获取beans，切入点也就是bolt的prepare()方法中。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Topology的初始化流程]]></title>
      <url>%2F2017%2F05%2F31%2Fstorm-life-cycle%2F</url>
      <content type="text"><![CDATA[1、 首先配置好topology，并定义好Spout实例和Bolt实例 2、 在提交Topology实例给Nimbus的过程中，会调TopologyBuilder实例的createTopology()方法，以获取定义的Topology实例。在运行createTopology()方法的过程中，会去调用Spout和Bolt实例上的declareOutputFields()方法和getComponentConfiguration()方法，declareOutputFields()方法配置Spout和Bolt实例的输出，getComponentConfiguration()方法输出特定于Spout和Bolt实例的配置参数值对。Storm会将以上过程中得到的实例，输出配置和配置参数值对等数据序列化，然后传递给Nimbus。 3、在Worker Node上运行的thread，从Nimbus上复制序列化后得到的字节码文件，从中反序列化得到Spout和Bolt实例，实例的输出配置和实例的配置参数值对等数据，在thread中Spout和Bolt实例的declareOutputFields()和getComponentConfiguration()不会再运行。 4、在thread中，反序列化得到一个Bolt实例后，它会先运行Bolt实例的prepare()方法，在这个方法调用中，需要传入一个OutputCollector实例，后面使用该OutputCollector实例输出Tuple 5、接下来在该thread中按照配置数量建立task集合，然后在每个task中就会循环调用thread所持有Bolt实例的execute()方法 6、在关闭一个thread时，thread所持有的Bolt实例会调用cleanup()方法 不过如果是强制关闭，这个cleanup()方法有可能不会被调用到]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[storm 启动相关命令]]></title>
      <url>%2F2017%2F05%2F31%2Fstart-storm-command%2F</url>
      <content type="text"><![CDATA[在启动storm之前要确保nimbus和supervisor上的Zookeeper已经启动1.查看zk的状态：./zkServer.sh status 2.如果zk没有开启，将nimbus和supervisor的zk开启./zkServer.sh start 3.启动nimbus（切换到storm的bin目录下）nohup ./storm nimbus &amp; 4.启动supervisornohup ./storm supervisor &amp; 4.启动storm UInohup ./storm ui &amp; 在浏览器中输入ip:8080/index.html进入storm UI界面（注意端口不一定是8080，注意配置）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F04%2F20%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
